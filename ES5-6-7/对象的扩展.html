<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>
		
	</title>
</head>
<body>





<script type="text/javascript">
	
	let obj = {
		getThis,
		getThis2(){
			console.log(this);
		}
	};

	obj.getThis();
	obj.getThis2();

	function getThis(){
		console.log(this);
	}

	/*	
		Object.is(x,y)
		ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。
		JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
		ES6 提出“Same-value-equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
		

		Object.assign(target,...args)  方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
		Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
		Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

		const target = { a: 1 };

		const source1 = { b: 2 };
		const source2 = { c: 3 };

		Object.assign(target, source1, source2);
		target // {a:1, b:2, c:3}


		ES6 一共有 5 种方法可以遍历对象的属性。

		（1）for...in

		for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

		（2）Object.keys(obj)

		Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

		（3）Object.getOwnPropertyNames(obj)

		Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含继承的属性，不含 Symbol 属性，但是包括不可枚举属性）的键名。

		（4）Object.getOwnPropertySymbols(obj)

		Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

		（5）Reflect.ownKeys(obj)

		Reflect.ownKeys返回一个数组，不含继承的属性，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

		以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

		首先遍历所有数值键，按照数值升序排列。
		其次遍历所有字符串键，按照加入时间升序排列。
		最后遍历所有 Symbol 键，按照加入时间升序排列


		前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。

		const obj = {
		  foo: 123,
		  get bar() { return 'abc' }
		};

		Object.getOwnPropertyDescriptors(obj)
		// { foo:
		//    { value: 123,
		//      writable: true,
		//      enumerable: true,
		//      configurable: true },
		//   bar:
		//    { get: [Function: get bar],
		//      set: undefined,
		//      enumerable: true,
		//      configurable: true
			  } 
			}


		Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。

		// 格式
		Object.setPrototypeOf(object, prototype)

		// 用法
		const o = Object.setPrototypeOf({}, null);
		该方法等同于下面的函数。

		function (obj, proto) {
		  obj.__proto__ = proto;
		  return obj;
		}

		该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。

		Object.getPrototypeOf(obj);

		我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。

		const proto = {
		  foo: 'hello'
		};

		const obj = {
		  foo: 'world',
		  find() {
		    return super.foo;
		  }
		};

		Object.setPrototypeOf(obj, proto);
		obj.find() // "hello"

		注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。
		// 报错
		const obj = {
		  foo: super.foo
		}

		// 报错
		const obj = {
		  foo: () => super.foo
		}

		// 报错
		const obj = {
		  foo: function () {
		    return super.foo
		  }
		}

		上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。

		JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。

		ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
		ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。
		Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
		Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。


	*/

</script>	

</body>
</html>